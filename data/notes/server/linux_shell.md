# LINUX SHELL

## LINUX 目录

```
 /bin：bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。

 /boot：这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。

 /dev ：dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。

 /etc：etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。

 /home：用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。

 /lib：lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。

 /lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。

 /media：linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。

 /mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。

 /opt：opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。

 /proc：proc 是 Processes(进程) 的缩写，

 /proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。
  这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：

```

## 变量

* 类型
  > 1) __局部变量__ 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。
  > 2) __环境变量__ 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。
  > 3) __脚本变量__ shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行

* 自定义变量
  > 变量名前面加美元符号:
  > * echo $your_name
  > * echo ${your_name} 加花括号是为了帮助解释器识别变量的边界

* 变量赋值  (   赋值的时候不能写$your_name="alibaba"，使用变量的时候才加美元符（$）)

  ```
     your_name="tom"  
     echo $your_name  
     your_name="alibaba"  
     echo $your_name  
  ```

* readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变

  ```
    myUrl = "https://www.google.com"  
    readonly myUrl
  ```

* 删除变量  
  ```unset variable_name```
* 环境变量
  > __$HOME__ 当前用户的登录子目录  
  > __$PATH__ 以冒号分隔的用来搜索的子目录清单   
  > __$0__    shell脚本程序的名字

* 读取环境变量的方法：
  > __export__ 命令显示当前系统定义的所有环境变量  
  > __echo__ $+关键字 命令输出当前的PATH环境变量的值
* 执行脚本的时候，需要往一个文件里自动输入N行内容。
  > 如果是少数的几行内容，还可以用echo追加方式，但如果是很多行，那么单纯用echo追加的方式就显得愚蠢之极了！
  > * 向文件test.sh里输入内容 cat << EOF >test.sh
  > * 追加内容 cat << EOF >>test.sh
  > * 覆盖内容 cat << EOF >test.sh


* 双引号
  > 双引号里可以有变量  
  > 双引号里可以出现转义字符

* basename dirname 的区别 /usr/lib/shell.sh

  |path|basename|dirname|  
                                                                                                                                                                                                                                      |----|--------|-------|
  |/usr/lib/shell.sh/lib|shell.sh |/usr/lib|

## 字符串

* 关键字
  > __$$__ ：Shell本身的PID（ProcessID）   
  > __$!__ ：Shell最后运行的后台Process的PID     
  > __$?__ ：最后运行的命令的结束代码（返回值）   
  > __$0__ ：Shell本身的文件名 1~n：添加到Shell的各参数值。$1是第1参数、$2是第2参数

* 单引号字符串的限制：
  > 单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；  
  > 单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。

* 获取字符串长度
  > string="abcd"  
  > echo ${#string} #输出 4

* 提取子字符串
  > string="runoob is a great site"  
  > echo ${string:1:4} # 输出 unoo

* 查找子字符串
  > string="runoob is a great site"  
  > echo `expr index "$string" io`  # 输出 4

## Shell 基本运算符

* 算术运算符

  |运算符|说明|举例|
                                                                                                                                                          |---|---|---|
  |+| 加法|    `expr $a + $b` 结果为 30   |
  |-| 减法|    `expr $a - $b` 结果为 -10   |
  |*| 乘法|    `expr $a \* $b` 结果为 200。| 
  |/| 除法|    `expr $b / $a` 结果为 2。   |
  |%| 取余|    `expr $b % $a` 结果为 0。   | 
  |=| 赋值|    `a=$b 把变量 b 的值赋给 a。   | 
  |==|  相等|用于比较两个数字，相同则返回 true。    [ $a == $b ] 返回 false。|
  |!=| 不相等|用于比较两个数字，不相同则返回 true。    [ $a != $b ] 返回 true。|

* 关系运算符

  |运算符|说明|举例|
                                                                                                                                          |---|---|---|
  |-eq| 检测两个数是否相等，相等返回 true                |    [ $a -eq $b ] 返回 false|
  |-ne| 检测两个数是否不相等，不相等返回 true             |    [ $a -ne $b ] 返回 true |
  |-gt| 检测左边的数是否大于右边的，如果是，则返回 true     |    [ $a -gt $b ] 返回 false|
  |-lt| 检测左边的数是否小于右边的，如果是，则返回 true     |    [ $a -lt $b ] 返回 true |
  |-ge| 检测左边的数是否大于等于右边的，如果是，则返回 true。|    [ $a -ge $b ] 返回 false|
  |-le| 检测左边的数是否小于等于右边的，如果是，则返回 true。|    [ $a -le $b ] 返回 true |

* 布尔运算符

  |运算符|说明|举例|
                                                                                                                                          |---|---|---|
  |!    |非运算，表达式为 true 则返回 false，否则返回 true。    |[ ! false ] 返回 true。|
  |-o|    或运算，有一个表达式为 true 则返回 true。        |[ $a -lt 20 -o $b -gt 100 ] 返回 true。|
  |-a|    与运算，两个表达式都为 true 才返回 true。        |[ $a -lt 20 -a $b -gt 100 ] 返回 false。|

* 字符串运算符

  |运算符|说明|举例|
                                                                                                                                          |---|---|---|
  |=    |检测两个字符串是否相等，相等返回 true          |[ $a = $b ] 返回 false。|
  |!=   |检测两个字符串是否不相等，不相等返回 true       |[ $a != $b ] 返回 true。|
  |-z   |检测字符串长度是否为0，为0返回 true           |[ -z $a ] 返回 false。|
  |-n   |检测字符串长度是否不为 0，不为 0 返回 true     |[ -n "$a" ] 返回 true。|
  |$    |检测字符串是否为空，不为空返回 true            |[ $a ] 返回 true。|

* 文件测试运算符

  |运算符|说明|举例|
                                                                                                                                            |---|---|---|
  |-b file    |检测文件是否是块设备文件，如果是，则返回 true。                           |[ -b $file ] 返回 false。|
  |-c file    |检测文件是否是字符设备文件，如果是，则返回 true。                          |[ -c $file ] 返回 false。|
  |-d file    |检测文件是否是目录，如果是，则返回 true。                                |[ -d $file ] 返回 false。|
  |-f file    |检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。    |[ -f $file ] 返回 true。|
  |-g file    |检测文件是否设置了 SGID 位，如果是，则返回 true。                         |[ -g $file ] 返回 false。|
  |-k file    |检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。               |[ -k $file ] 返回 false。|
  |-p file    |检测文件是否是有名管道，如果是，则返回 true。                              |[ -p $file ] 返回 false。|
  |-u file    |检测文件是否设置了 SUID 位，如果是，则返回 true。                         |[ -u $file ] 返回 false。|
  |-r file    |检测文件是否可读，如果是，则返回 true。                                   |[ -r $file ] 返回 true。|
  |-w file    |检测文件是否可写，如果是，则返回 true。                                   |[ -w $file ] 返回 true。|
  |-x file    |检测文件是否可执行，如果是，则返回 true。                                  |[ -x $file ] 返回 true。|
  |-s file    |检测文件是否为空（文件大小是否大于0），不为空返回 true。                      |[ -s $file ] 返回 true。|
  |-e file    |检测文件（包括目录）是否存在，如果是，则返回 true。                         |[ -e $file ] 返回 true。|

* printf 的转义序列

  |序列|说明|
                                                                                                                                              |---|---|
  |\a        |警告字符，通常为ASCII的BEL字符|
  |\b        |后退|
  |\c        |抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略|
  |\f        |换页（formfeed）|
  |\n        |换行|
  |\r        |回车（Carriage return）|
  |\t        |水平制表符|
  |\v        |垂直制表符|
  |\\        |一个字面上的反斜杠字符|
  |\ddd        |表示1到3位数八进制值的字符。仅在格式字符串中有效|
  |\0ddd    |表示1到3位的八进制值字符|

* test 命令

  |参数|说明|
                                                                                                                                                |---|---|
  |-eq    |等于则为真|
  |-ne    |不等于则为真|
  |-gt    |大于则为真|
  |-ge    |大于等于则为真|
  |-lt    |小于则为真|
  |-le    |小于等于则为真|

  ```
   num1=100  
   num2=100  
   if test $[num1] -eq $[num2]  
   then  
   echo '两个数相等！'  
   else  
   echo '两个数不相等！'  
   fi
  ```

* 文件测试

  |参数|说明|
                                                                                                                                                  |---|---|
  |-e 文件名    |如果文件存在则为真|
  |-r 文件名    |如果文件存在且可读则为真|
  |-w 文件名    |如果文件存在且可写则为真|
  |-x 文件名    |如果文件存在且可执行则为真|
  |-s 文件名    |如果文件存在且至少有一个字符则为真|
  |-d 文件名    |如果文件存在且为目录则为真|
  |-f 文件名    |如果文件存在且为普通文件则为真|
  |-c 文件名    |如果文件存在且为字符型特殊文件则为真|
  |-b 文件名    |如果文件存在且为块特殊文件则为真|

## echo

* 输出日期 echo `date`

## grep

* grep name file 过滤需要的内容
* grep -v name file 过滤不需要的内容

> 去除grep本身的进程 :
```ps -ef | grep docker | grep -v grep```

## 文件测试

```
  -z string 测试指定字符是否为空，空着真，非空为假   
  -n string 测试指定字符串是否为不空，空为假 非空为真  
  -e FILE 测试文件是否存在  
  -f file 测试文件是否为普通文件  
  -d file 测试指定路径是否为目录  
  -r file 测试文件对当前用户是否可读  
  -w file 测试文件对当前用户是否可写  
  -x file 测试文件对当前用户是都可执行  
  -z 是否为空 为空则为真  
  -a 是否不空  
```

## exit

* exit(1)表示异常退出.这个1是返回给操作系统的不过在DOS好像不需要这个返回值
* exit(0)表示正常退出
  ```
  无论写在那里，都是程序推出，dos和windows中没有什么不一样，最多是系统处理的不一样。 数字0,1,-1会被写入环境变量ERRORLEVEL，其它程序可以由此判断程序结束状态。
  一般0为正常推出，其它数字为异常，其对应的错误可以自己指定。
  ```

## RETVAL 返回值

## CASE

```
    case 模式值 in
        模式1)
            command1
            command2
            command3
            ;;
        模式2）
            command1
            command2
            command3
            ;;
          *)
            command1
            command2
            command3
            ;;
    esac
```
